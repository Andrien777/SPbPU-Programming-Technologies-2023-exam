#на5
**SAM (Single Abstract Method), или функциональные, интерфейсы** - интерфейсы, содержащие ровно один метод без тела. default методы, а также переопределение методов из Object допустимы. Для обозначения и проверки используется аннотация @FunctionalInterface. Наследование функционального интерфейса разрешено. Наследник тоже будет функциональным интерфейсом, если не добавляет иных абстрактных методов.

**Lambda-выражения** можно считать [[Локальные классы, Анонимные классы#Анонимные классы|анонимными классами]], реализующими функциональные интерфейсы. Их можно присваивать переменным с соответствующим типом или передавать в качестве аргументов.
Синтаксис: 
```java
(type1 arg1, type2 arg2...) -> {...}; //опционально return, указание типов опционально
() -> {...};
(type1 arg1, type2 arg2...) -> someAction(...); //return не нужен, возвращается результат someAction
arg -> {...};
arg -> someAction(arg);
```
Особенности лямбд:
* локальные переменные уровня класса можно читать и менять
* локальные переменные уровня метода можно читать, если они final, нельзя записывать
* аргументы нельзя изменять

Примеры функциональных интерфейсов: **Runnable (используемый в [[Threads]]), Callable, Comparator, Consumer** и т.д.